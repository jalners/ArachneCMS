@model WWW.ViewModels.PageModel
@{
    Model.Meta.Title = "Принципы SOLID / ArachneCMS";
    //TODO:Metas
    Model.Meta.OpenGraph.Add("url", this.Request.Url.ToString());
    Model.Meta.OpenGraph.Add("title", Model.Meta.Title);
    Model.Meta.OpenGraph.Add("image", this.Request.Url + "/pillars.jpg");
    Model.Meta.OpenGraph.Add("description", "SOLID &mdash; под такой меткой аббревиатурой Майкла Физерса мир знает пять основных архитектурных принципов, предложенных Робертом \"Дядя Боб\" Мартином.");
}

<div class="page-title">
    <div class="container">
        <h1>Принципы SOLID</h1>
        <ul class="breadcrumb">
            <li><a href="/">В начало</a></li>
            <li><a class="todo" href="#/ru/wiki">Вики</a></li>
        </ul>
    </div>
</div>

<div class="container main-content clearfix">
    <img src="/ru/wiki/solid-printsipy/pillars.jpg" alt="Столпы" class="image-right" />

    <p>
        SOLID &mdash; под такой меткой аббревиатурой Майкла Физерса мир знает пять основных
        архитектурных принципов, предложенных Робертом &laquo;Дядя Боб&raquo; Мартином.
    </p>

    <p>
        Считается, что их использование делает дизайн вашего ПО менее 
        <a class="todo" href="#/ru/wiki/todo">жестким</a> и 
        <a class="todo" href="#/ru/wiki/todo">хрупким</a>, с более высоким потенциалом роста и
        повторного использования. Не доверять этому причин нет. Практически все критики стараются
        избегать прямой атаки самих принципов и больше говорят о примерах их чрезмерного
        использования. Во многом они правы. SOLID &mdash; как чистый спирт. Химически он
        безупречен, но многие из нас скорее предпочтут водку, виски или вино. Так что мы бы
        посоветовали &laquo;разбавлять&raquo; эти принципы в рамках разумного.
    </p>
</div>

<div class="container main-content clearfix">
    <a id="srp" title="SRP"></a>
    <h2><strong>S</strong>Single responsibility principle (SRP)</h2>
    <p>
        Принцип единственной обязанности. Старайтесь не возлагать на один объект более одной
        функциональной обязанности. И уж тем более, старайтесь избегать создания
        <a class="todo" href="#/ru/wiki/todo">божественных классов</a>.
    </p>

    <p>
        Здесь и далее мы будем позволять себе отклоняться от &laquo;буквы закона&raquo;, но
        стараться сохранять ее дух. Дословно Роберт Мартин говорил об этом принципе как: &laquo;Не
        должно быть более одной причины для изменения класса&raquo;. Нам кажется, что хотя всякая
        новая обязанность является причиной для изменений, не всякая причина является
        обязанностью. Мы можем захотеть модернизировать класс из чувства прекрасного, проведя
        рефакторинг. Или в рамках работы над производительностью. Таких причин может быть много,
        а обязанность останется одна.
    </p>

    <p>
        Также мы намеренно говорим о функциональных объектах в целом, поскольку принцип с равным
        успехом можно использовать не только для классов, но и для функций с модулями. Меняться
        будет лишь масштаб обязанностей.
    </p>

    <p>
        Каковы же последствия несоблюдения этого принципа? Каждая новая функциональная обязанность
        &mdash; это еще одна причина для изменений вашего объекта. А значит работать с ним придется
        чаще. С другой стороны, обязанность &mdash; это еще и дополнительный код, что практически
        всегда ведет к повышению его <a class="todo" href="#/ru/wiki/hrupkost-koda">хрупкости</a>
        и ослаблению контроля. А значит изменения вносить будет тяжелее и риски ошибок выше. Чаще
        умноженное на тяжелее &mdash; так мы получаем удвоенный рост сложности. Стоит немного
        злоупотребить, и ситуация начинает развиваться по сценарию снежного кома, под действием
        силы, которую мы назвали <a href="/ru/wiki/gravitatsiya-koda">гравитацией кода</a>.
    </p>

    <p>
        В награду за следование этому принципу мы получаем, помимо прочего, более широкие
        возможности повторного использования. Как только мы выделяем некоторую обязанность из
        сложного класса, то помимо ее использования в составе этого класса у нас появляется и
        возможность использовать ее отдельно. Чтобы облегчить понимание рассмотрим это на примере
        существующей кодовой базы.
    </p>

    <p>
        Простым экземпляром несоблюдения данного принципа является класс System.Object в
        Microsoft .NET Framework. Сигнатуры его публичных методов выглядят так:
    </p>

    <code><em>public</em> <em>virtual</em> <em>bool</em> Equals(<em>object</em> <var>obj</var>);
<em>public</em> <em>virtual</em> <em>int</em> GetHashCode();
<em>public</em> <em>virtual</em> <em>string</em> ToString();
<em>public</em> <em>extern</em> <a>Type</a> GetType();</code>

    <p>
        Из чего следует, что он берет на себя обязанности сравнения объектов, вычисления
        их хеш-суммы и конвертации в строку. Тенденция плохая, но поскольку объект легковесный,
        мы не замечаем серьезных неудобств. Другое дело, когда доведется столкнуться с чем-то
        более крупным. Скажем, классом System.Data.DataTable. Его основная обязанность &mdash;
        управление реляционными таблицами в памяти. Но когда смотришь на добрых семь с лишним
        тысяч строк одного этого класса, которые, помимо прочего, берут на себя обязанности по
        копированию таблиц, клонированию, слиянию, (де)сериализации, работе со схемами и много
        другое, то мечтаешь никогда в жизни не столкнуться с задачей по его модернизации.
    </p>
    <p>
        Видимо, того же мнения придерживаются и инженеры Microsoft. За множество последних версий
        такие новшества как обобщенные классы, лямбда-выражения, расширяющие методы вкупе с LINQ
        привели к пересмотру большинства подсистем. Казалось бы, DataTable мог вобрать фактически
        все перечисленное. Оперировать типизированными кортежами на базе обобщенных типов,
        использовать лямбда-выражения для описания внешних ключей, индексов, выражений запросов.
        Не ограничиваться примитивной конвертацией в итератор для LINQ. Но практически с первых
        своих версий его дизайн не изменился никак.
    </p>
    <p>
        Помимо того, что несоблюдение принципа SRP завело DataTable в тупик, надо с сожалением
        отметить, что все эти семь с лишним тысяч строк кода не несут никакой пользы всей
        остальной системе. Казалось бы, реализованная обязанность по сохранению табличных данных
        в XML-файл может быть использована и для классов, реализующих интерфейс IDataReader.
        Ведь это те же самые табличные данные, получаемые из реляционной СУБД. Но увы, данная
        функциональность является неотъемлемой частью класса DataTable и использоваться отдельно
        от него не может.
    </p>

    <p>
        Но у данного принципа есть и оборотная сторона &mdash; когда мы увлекаемся
        микро обязанностями. Справляться с неоправданно большим количеством объектов сложнее.
        Хотя даже в этом случае риски гораздо меньше, чем при несоблюдении принципа SRP.
    </p>
</div>

<div class="container main-content clearfix">
    <a id="ocp" title="OCP"></a>
    <h2><strong>O</strong>Open/closed principle (OCP)</h2>
    <p>
        Принцип открытости/закрытости. Программные сущности должны быть открыты для расширения,
        но закрыты для изменения.
    </p>
    <p>
        Данный принцип не является мораторием на изменение кода. Он лишь дает нам совет, которому
        стоит следовать при проектировании новой сущности. Она должна быть такой, чтобы изменение
        поведения не требовало внесения изменений в исходный код, а могло быть реализовано путем
        его расширения.
    </p>
    <p>
        Возьмем в качестве примера все тот же System.Object, упомянутый в принципе
        <a href="#srp">SRP</a>. Он содержит метод GetHashCode, вычисляющий хеш-сумму некоторого
        объекта. И им же пользуется класс System.Collections.Hashtable для организации
        хеш-таблицы из объектов.
    </p>
    <p>
        Предположим, мы планируем реализовать более производительную хеш-таблицу с меньшим
        количеством коллизий. Для этого хотелось бы просто заменить хеш-функцию на нашу, более
        эффективную, оставив всю остальную инфраструктуру Hashtable как есть.
    </p>
    <p>
        Но System.Object создан в Microsoft, а значит он закрыт для наших изменений по факту. И не
        имей мы способов расширения класса Hashtable, его пришлось бы переписывать для решения
        нашей задачи...
    </p>
    <p>
        К счастью, нам достаточно реализовать нашу хеш-функцию с интерфейсом 
        System.Collections.IHashCodeProvider и передать объект с ней в качестве аргумента
        конструктору Hashtable.
    </p>
    <code><em>public</em> <em>class</em> MyCustomHashProvider : <a>System.Collections.IHashCodeProvider</a>
{
    <em>int</em> <a>System.Collections.IHashCodeProvider</a>.GetHashCode(<em>object</em> obj)
    {
        <q>...вычисление новой хеш-функции...</q>
    }
}

...
<em>var</em> provider = <em>new</em> <a>MyCustomHashProvider</a>();
<a>Hashtable</a> hashtable = <em>new</em> <a>Hashtable</a>(provider, ...);
...
    </code>
    <p>
        Это пример того, как сущность закрыта для изменений, поскольку мы технически не имеем
        возможности заменить код классов Object или Hashtable своим. Но в тоже время последний
        открыт для расширения в части изменений алгоритма хеширования.
    </p>
    <p>
        Безусловно, не стоит бездумно гнаться за всеми возможными способами расширения ваших
        сущностей. Но если мы стараемся соблюдать
        <a href="#srp">принцип единственной обязанности</a>, то их будет не так много и, скорее
        всего, они окажутся на поверхности.
    </p>
</div>

<div class="container main-content clearfix">
    <a id="lsp" title="LSP"></a>
    <h2><strong>L</strong>Liskov substitution principle (LSP)</h2>
    <p>
        Принцип подстановки Лисков. Барбара Лисков и Жанетта Винг сформулировали этот принцип
        так: &laquo;Пусть q(x) является свойством, верным для объектов x типа T. Тогда q(y)
        также должно быть верным для объектов y типа S, где S является подтипом типа T&raquo;.
    </p>
    <p>
        В быту мы говорим о том, что поведение, заданное для некоторого типа объектов должно
        оставаться неизменным для всех его подтипов. И, сами создавая такой подтип, мы должны
        следить за тем, чтобы он не нарушил работу существующего кода, который до нас прекрасно
        работал с этими типами.
    </p>
    <p>
        Предположим у нас существует такой метод, который безупречно экспортировал данные в
        любые списки с интерфейсом System.Collections.IList.
    </p>
    <code><em>public</em> <em>void</em> ExportToList(<a>IList</a> list)
{
    <em>foreach</em> (<em>var</em> row <em>in</em> <em>this</em>.Rows) {
        list.Add(row);
    }
}</code>
    <p>
        При его реализации мы полагались на документацию, которая убеждала, что метод IList.Add
        добавляет заданный объект в список, что прекрасно работало для таких классов как
        System.Collections.ArrayList, System.Collections.Generic.List и многих других. Но в
        команде Microsoft решили, что класс System.Array тоже должен реализовывать интерфейс IList.
        Причины такого решения не понятны, поскольку между массивами и списками есть существенные
        отличия. Одно из них &mdash; невозможность добавить элемент. На что ими было
        найдено &laquo;оригинальное&raquo; решение &mdash; выбрасывать исключение
        NotSupportedException при попытке вызвать IList.Add. Как результат, наш экспорт в объекты
        Array прекрасно компилируется, но вызывает ошибку во время исполнения.
    </p>
    <p>
        Таким образом принцип подстановки Лисков очень удобен для оценки правильности
        организованной зависимостей. Поэтому наиболее частыми примерами нарушения
        <a href="#lsp">LSP</a> являются софизмы вроде &laquo;квадрат &mdash; не
        прямоугольник&raquo;, &laquo;круг &mdash; не эллипс&raquo; и &laquo;страус &mdash; не
        птица&raquo;. Предположим, у нас есть следующий базовый класс для пернатых:
    </p>
    <code><em>public</em> <em>abstract</em> <em>class</em> Bird
{
    <em>public</em> <em>virtual</em> <em>double</em> Altitude
    {
        <em>get</em>;
        <em>set</em>;
    }

    <em>public</em> <em>virtual</em> <em>void</em> Fly(<em>double</em> altitude)
    {
        ...
        <em>this</em>.Altitude = altitude;
    }
}
    </code>
    <p>
        Если мы попытаемся наследовать от него страуса, то придется менять практически все
        приведенные свойства и методы, поскольку мы не должны дать страусу взлететь. Но с другой
        стороны, тот код, который был рассчитан на то, что птицы летают, будет работать
        непредсказуемо. Сложности с реализацией принципа <a href="#lsp">LSP</a> являются
        диагностическим признаком, что иерархия классов была спроектирована с ошибками.
    </p>
    <p>
        Отдельно стоит сказать о причинах отступления от интерпретации Мартина, которое звучит
        как &laquo;Функции, которые используют указатели или ссылки на базовые классы должны
        уметь использовать и объекты унаследованных классов, даже не подозревая об их
        существовании&raquo;. Нам эта формулировка кажется не совсем корректной. Мелочами вроде
        тех, что речь идет о ссылках на классы, а не объекты и область применения сужена только
        до классов, можно было бы пренебречь. Но формулировка такова, что обязанность соблюдать
        принцип Лисков возложена не на те объекты. Функции, как в примере с методом ExportToList выше,
        полагаются на документированное поведение. Они не могут проконтролировать все реализации
        IList на планете. Поэтому обязанность не должна возлагаться на потребителей.
    </p>
</div>

<div class="container main-content clearfix">
    <a id="isp" title="ISP"></a>
    <h2><strong>I</strong>Interface segregation principle (ISP)</h2>
    <p>
        Принцип разделения интерфейса. Клиент не должен понуждаться к зависимости от интерфейсов,
        которыми он не пользуется. Каждая лишняя зависимость является риском того, что изменение
        интерфейса повлечет за собой необходимость изменения клиента.
    </p>
    <p>
        Возьмем в качестве примера классы уже знакомые нам по принципу <a href="#ocp">OCP</a>
        &mdash; IHashProvider и Hashtable. Примечательно то, что в последних версиях .NET
        Framework, Microsoft пометила интерфейс IHashProvider как устаревший, предлагая вместо
        него использовать интерфейс System.Collections.IEqualityComparer, который выглядит как:
    </p>
    <code><em>public</em> <em>interface</em> IEqualityComparer
{
    <em>bool</em> Equals(<em>object</em> x, <em>object</em> y);
    <em>int</em> GetHashCode(<em>object</em> obj);
}</code>
    <p>
        Теперь именно его надо передавать в конструктор класса Hashtable. Хотя сам Hashtable
        использует только метод GetHashCode. Теперь, если какие-то изменения потребуется внести
        в метод Equals, то класс Hashtable столкнется с проблемами, хотя он этот метод вообще
        не использует. Если бы мы разделили этот интерфейс на два других, также существующих
        в .NET Framework:
    </p>
    <code><em>public</em> <em>interface</em> IEqualityComparer : <a>IHashCodeProvider</a>, <a>IComparer</a>
{
    ...
}</code>
    <p>
        А в класс Hashtable передавали только IHashCodeProvider, то такой проблемы бы не было.
    </p>
    <p>
        Часто приводят вариант прочтения этого принципа, который гласит, что много маленьких
        интерфейсов лучше, чем один большой. Использование метрик &laquo;большой&raquo; или
        &laquo;маленький&raquo; вызывает больше вопросов, чем ответов. Лучше воспользоваться
        принципом <a href="#srp">SRP</a> и разделять интерфейсы по обязанностям. Не важно,
        какого они будут размера.
    </p>
</div>

<div class="container main-content clearfix">
    <a id="dip" title="DIP"></a>
    <h2><strong>D</strong>Dependency inversion principle (DIP)</h2>
    <p>
        Принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей
        нижнего уровня. И те, и другие должны зависеть от независимых абстракций.
    </p>

    <p>
        Представьте себе на минуту мир без вилок и розеток, компьютеры без разъемов PCI, SATA,
        USB и прочих. Купили новый графический ускоритель? Аккуратно отпаяйте старый и,
        внимательно прочитав спецификацию к новому, соедините его с нужными точками на
        материнской плате.
    </p>

    <p>
        Принцип DIP предлагает избавиться от необходимости материнской плате знать что-либо
        о конкретных устройствах. Она просто предоставляет ранее упомянутые разъемы, тем самым
        декларируя свою готовность работать с одноименными интерфейсами. Обязанность
        реализовывать эти интерфейсы ложится на конечные детали вашего компьютера. Таким
        образом мы разворачиваем зависимость в обратном направлении. Теперь материнская плата
        ничего не должна знать о вашей клавиатуре. Но она знает о такой &laquo;абстракции&raquo;
        как USB-интерфейс. Сама клавиатура знает как реализовывать USB-интерфейс и зависит от его
        поддержки материнской платой.
    </p>

    <p>
        Пример инверсии зависимости мы уже видели ранее, при изучении принципа
        <a href="#ocp">OCP</a>. Класс Hashtable &mdash; это была наша материнская плата. Мы не
        хотели вводить прямую зависимость от разных реализаций вычисления хеш-функции и
        использовали абстракцию IHashCodeProvider. Это &mdash; аналог USB-интерфейса. В роли
        клавиатуры выступил наш класс MyCustomHashProvider, который реализовал эту абстракцию.
        И как провод USB-клавиатуры вставляется в USB-разъем, мы &laquo;вставили&raquo; наш
        провайдер в конструктор Hashtable.
    </p>
</div>
